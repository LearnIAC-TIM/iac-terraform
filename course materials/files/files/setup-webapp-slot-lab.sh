#!/bin/bash
set -e

# Farger for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${BLUE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
echo -e "${BLUE}‚ïë   Azure Web App Slots Lab - Setup Script                  ‚ïë${NC}"
echo -e "${BLUE}‚ïë   Praktisk √∏velse i deployment slots og CI/CD             ‚ïë${NC}"
echo -e "${BLUE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
echo ""

# Opprett hovedmapper
echo -e "${GREEN}üìÅ Oppretter mappestruktur...${NC}"
mkdir -p lab-webapp-slots/{terraform,app,scripts,tests,.github/workflows,docs}

cd lab-webapp-slots

# ============================================================================
# TERRAFORM KONFIGURASJON
# ============================================================================

echo -e "${GREEN}üìù Genererer Terraform-konfigurasjon...${NC}"

cat > terraform/main.tf << 'EOF'
terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }
  }
}

provider "azurerm" {
  features {}
}

# Resource Group
resource "azurerm_resource_group" "lab" {
  name     = var.resource_group_name
  location = var.location

  tags = var.required_tags
}

# App Service Plan (Linux)
resource "azurerm_service_plan" "lab" {
  name                = "${var.prefix}-asp"
  resource_group_name = azurerm_resource_group.lab.name
  location            = azurerm_resource_group.lab.location
  os_type             = "Linux"
  sku_name            = "B1" # Basic tier for kostnadseffektivitet

  tags = var.required_tags
}

# Web App
resource "azurerm_linux_web_app" "lab" {
  name                = "${var.prefix}-webapp-${var.environment}"
  resource_group_name = azurerm_resource_group.lab.name
  location            = azurerm_resource_group.lab.location
  service_plan_id     = azurerm_service_plan.lab.id

  # Sikkerhetskonfigurasjon
  https_only = true

  site_config {
    minimum_tls_version = "1.2"
    
    application_stack {
      python_version = "3.11"
    }

    # Health check
    health_check_path = "/health"
  }

  app_settings = {
    "ENVIRONMENT"      = "production"
    "FEATURE_TOGGLE_X" = "false"
    "SCM_DO_BUILD_DURING_DEPLOYMENT" = "true"
  }

  # FTP deaktivert for sikkerhet
  ftp_publish_basic_authentication_enabled = false
  
  tags = var.required_tags
}

# Staging Slot
resource "azurerm_linux_web_app_slot" "staging" {
  name           = "staging"
  app_service_id = azurerm_linux_web_app.lab.id

  https_only = true

  site_config {
    minimum_tls_version = "1.2"
    
    application_stack {
      python_version = "3.11"
    }

    health_check_path = "/health"
  }

  app_settings = {
    "ENVIRONMENT"      = "staging"
    "FEATURE_TOGGLE_X" = "true"  # Feature toggle aktivert i staging
    "SCM_DO_BUILD_DURING_DEPLOYMENT" = "true"
  }

  ftp_publish_basic_authentication_enabled = false

  tags = merge(var.required_tags, {
    Slot = "staging"
  })
}
EOF

cat > terraform/variables.tf << 'EOF'
variable "prefix" {
  description = "Prefix for alle ressurser"
  type        = string
  default     = "student"
}

variable "resource_group_name" {
  description = "Navn p√• resource group"
  type        = string
  default     = "rg-webapp-lab"
}

variable "location" {
  description = "Azure region"
  type        = string
  default     = "norwayeast"
}

variable "environment" {
  description = "Milj√∏ (dev/test/prod)"
  type        = string
  default     = "lab"
}

variable "required_tags" {
  description = "P√•krevde tags for compliance"
  type        = map(string)
  default = {
    Environment = "Lab"
    Project     = "WebAppSlots"
    ManagedBy   = "Terraform"
    CostCenter  = "Education"
  }
}
EOF

cat > terraform/outputs.tf << 'EOF'
output "webapp_name" {
  description = "Navn p√• Web App"
  value       = azurerm_linux_web_app.lab.name
}

output "webapp_url" {
  description = "URL til production slot"
  value       = "https://${azurerm_linux_web_app.lab.default_hostname}"
}

output "staging_url" {
  description = "URL til staging slot"
  value       = "https://${azurerm_linux_web_app.lab.name}-staging.azurewebsites.net"
}

output "resource_group_name" {
  description = "Resource group navn"
  value       = azurerm_resource_group.lab.name
}
EOF

# ============================================================================
# WEB APPLIKASJON (Python Flask)
# ============================================================================

echo -e "${GREEN}üêç Genererer Flask-applikasjon...${NC}"

cat > app/app.py << 'EOF'
from flask import Flask, jsonify
import os
import socket

app = Flask(__name__)

# Hent milj√∏variabler
ENVIRONMENT = os.getenv('ENVIRONMENT', 'unknown')
FEATURE_TOGGLE_X = os.getenv('FEATURE_TOGGLE_X', 'false').lower() == 'true'
VERSION = os.getenv('APP_VERSION', '1.0.0')

@app.route('/')
def home():
    """Hovedside med milj√∏informasjon"""
    return jsonify({
        'message': 'Azure Web App Slots Lab',
        'environment': ENVIRONMENT,
        'version': VERSION,
        'hostname': socket.gethostname(),
        'feature_x_enabled': FEATURE_TOGGLE_X
    })

@app.route('/health')
def health():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'environment': ENVIRONMENT,
        'checks': {
            'app': 'ok',
            'feature_toggle': FEATURE_TOGGLE_X
        }
    }), 200

@app.route('/feature-x')
def feature_x():
    """Feature toggle demo"""
    if FEATURE_TOGGLE_X:
        return jsonify({
            'feature': 'X',
            'enabled': True,
            'message': 'Dette er den nye funksjonen!',
            'environment': ENVIRONMENT
        })
    else:
        return jsonify({
            'feature': 'X',
            'enabled': False,
            'message': 'Feature X er ikke tilgjengelig enn√•.',
            'environment': ENVIRONMENT
        })

@app.route('/api/version')
def version():
    """Versjonsinformasjon"""
    return jsonify({
        'version': VERSION,
        'environment': ENVIRONMENT,
        'deployment_slot': 'staging' if 'staging' in ENVIRONMENT.lower() else 'production'
    })

if __name__ == '__main__':
    port = int(os.getenv('PORT', 8000))
    app.run(host='0.0.0.0', port=port, debug=False)
EOF

cat > app/requirements.txt << 'EOF'
Flask==3.0.0
gunicorn==21.2.0
Werkzeug==3.0.1
EOF

cat > app/startup.sh << 'EOF'
#!/bin/bash
echo "Starting application..."
gunicorn --bind=0.0.0.0:8000 --workers=2 --timeout=600 app:app
EOF

chmod +x app/startup.sh

# ============================================================================
# TEST SCRIPTS
# ============================================================================

echo -e "${GREEN}üß™ Genererer test-scripts...${NC}"

cat > scripts/test-offline.sh << 'EOF'
#!/bin/bash
# OFFLINE TESTING: Syntaks og linting

set -e

echo "üîç OFFLINE TESTING - Syntaks og Sikkerhet"
echo "========================================"

# Terraform validering
echo "‚Üí Validerer Terraform konfigurasjon..."
cd terraform
terraform fmt -check
terraform validate
cd ..

# Python syntax check
echo "‚Üí Sjekker Python syntaks..."
python3 -m py_compile app/app.py

# Sjekk for vanlige sikkerhetsproblemer i kode
echo "‚Üí Sjekker for hardkodet secrets..."
if grep -r "password\|secret\|key" app/*.py | grep -v "FEATURE_TOGGLE"; then
    echo "‚ùå ADVARSEL: Potensielle hardkodede secrets funnet!"
    exit 1
fi

echo "‚úÖ Alle offline tester best√•tt!"
EOF

cat > scripts/test-policy.sh << 'EOF'
#!/bin/bash
# CONNECTED STATIC ANALYSIS: Policy og compliance

set -e

echo "üîê POLICY TESTING - Compliance og Sikkerhet"
echo "=========================================="

cd terraform

# Terraform plan
echo "‚Üí Kj√∏rer Terraform plan..."
terraform plan -out=tfplan > /dev/null 2>&1

# Konverter plan til JSON for analyse
terraform show -json tfplan > tfplan.json

# Sjekk p√•krevde tags
echo "‚Üí Verifiserer p√•krevde tags..."
if ! grep -q '"Environment"' tfplan.json || ! grep -q '"ManagedBy"' tfplan.json; then
    echo "‚ùå FEIL: P√•krevde tags mangler!"
    exit 1
fi

# Sjekk HTTPS-only
echo "‚Üí Verifiserer HTTPS-only policy..."
if grep -q '"https_only.*false' tfplan.json; then
    echo "‚ùå FEIL: HTTPS-only er ikke aktivert!"
    exit 1
fi

# Sjekk FTP deaktivert
echo "‚Üí Verifiserer FTP er deaktivert..."
if grep -q '"ftp_publish_basic_authentication_enabled.*true' tfplan.json; then
    echo "‚ùå FEIL: FTP basic auth er aktivert (skal v√¶re deaktivert)!"
    exit 1
fi

# Sjekk minimum TLS version
echo "‚Üí Verifiserer TLS 1.2 minimum..."
if grep -q '"minimum_tls_version":"1\.[01]"' tfplan.json; then
    echo "‚ùå FEIL: TLS versjon er for lav!"
    exit 1
fi

rm tfplan tfplan.json

echo "‚úÖ Alle policy tester best√•tt!"
cd ..
EOF

cat > scripts/test-verify.sh << 'EOF'
#!/bin/bash
# ONLINE VERIFICATION: Sjekk at ressurser er korrekt konfigurert

set -e

WEBAPP_NAME=$1
RG_NAME=$2

if [ -z "$WEBAPP_NAME" ] || [ -z "$RG_NAME" ]; then
    echo "Usage: $0 <webapp-name> <resource-group-name>"
    exit 1
fi

echo "üîé VERIFICATION TESTING - Ressurskonfigurasjon"
echo "============================================="

# Sjekk at web app eksisterer
echo "‚Üí Verifiserer Web App eksisterer..."
if ! az webapp show --name "$WEBAPP_NAME" --resource-group "$RG_NAME" > /dev/null 2>&1; then
    echo "‚ùå FEIL: Web App $WEBAPP_NAME ble ikke funnet!"
    exit 1
fi

# Sjekk staging slot
echo "‚Üí Verifiserer staging slot..."
if ! az webapp deployment slot list --name "$WEBAPP_NAME" --resource-group "$RG_NAME" | grep -q "staging"; then
    echo "‚ùå FEIL: Staging slot ble ikke funnet!"
    exit 1
fi

# Sjekk HTTPS-only er aktivert
echo "‚Üí Verifiserer HTTPS-only konfigurasjon..."
HTTPS_ONLY=$(az webapp show --name "$WEBAPP_NAME" --resource-group "$RG_NAME" --query httpsOnly -o tsv)
if [ "$HTTPS_ONLY" != "true" ]; then
    echo "‚ùå FEIL: HTTPS-only er ikke aktivert!"
    exit 1
fi

# Sjekk app settings forskjeller
echo "‚Üí Verifiserer app settings forskjeller..."
PROD_ENV=$(az webapp config appsettings list --name "$WEBAPP_NAME" --resource-group "$RG_NAME" --query "[?name=='ENVIRONMENT'].value" -o tsv)
STAGING_ENV=$(az webapp config appsettings list --name "$WEBAPP_NAME" --resource-group "$RG_NAME" --slot staging --query "[?name=='ENVIRONMENT'].value" -o tsv)

if [ "$PROD_ENV" == "$STAGING_ENV" ]; then
    echo "‚ö†Ô∏è  ADVARSEL: ENVIRONMENT variabel er lik i begge slots!"
fi

echo "‚úÖ Alle verification tester best√•tt!"
EOF

cat > scripts/test-health.sh << 'EOF'
#!/bin/bash
# HEALTH CHECK: Test at applikasjonen svarer korrekt

set -e

URL=$1
EXPECTED_ENV=${2:-production}

if [ -z "$URL" ]; then
    echo "Usage: $0 <url> [expected-environment]"
    exit 1
fi

echo "üè• HEALTH CHECK - $URL"
echo "========================================"

# Vent p√• at appen er klar
echo "‚Üí Venter p√• at applikasjon starter..."
for i in {1..30}; do
    if curl -s -o /dev/null -w "%{http_code}" "$URL/health" | grep -q "200"; then
        break
    fi
    echo "  Fors√∏k $i/30..."
    sleep 2
done

# Health endpoint
echo "‚Üí Tester /health endpoint..."
RESPONSE=$(curl -s "$URL/health")
STATUS=$(echo "$RESPONSE" | jq -r '.status' 2>/dev/null || echo "error")

if [ "$STATUS" != "healthy" ]; then
    echo "‚ùå FEIL: Health check feilet!"
    echo "$RESPONSE"
    exit 1
fi

# Sjekk milj√∏
echo "‚Üí Verifiserer milj√∏..."
ENV=$(echo "$RESPONSE" | jq -r '.environment' 2>/dev/null || echo "unknown")
echo "  Milj√∏: $ENV (forventet: $EXPECTED_ENV)"

# Test hovedside
echo "‚Üí Tester hovedside..."
HOME_RESPONSE=$(curl -s "$URL/")
MESSAGE=$(echo "$HOME_RESPONSE" | jq -r '.message' 2>/dev/null || echo "")

if [ -z "$MESSAGE" ]; then
    echo "‚ùå FEIL: Kunne ikke hente response fra hovedside!"
    exit 1
fi

# Test feature toggle
echo "‚Üí Tester feature toggle..."
FEATURE_RESPONSE=$(curl -s "$URL/feature-x")
FEATURE_ENABLED=$(echo "$FEATURE_RESPONSE" | jq -r '.enabled' 2>/dev/null || echo "unknown")
echo "  Feature X enabled: $FEATURE_ENABLED"

echo "‚úÖ Alle health checks best√•tt!"
echo ""
echo "üìä Response summary:"
echo "$HOME_RESPONSE" | jq '.'
EOF

cat > scripts/swap-slots.sh << 'EOF'
#!/bin/bash
# SLOT SWAP: Bytt staging og production

set -e

WEBAPP_NAME=$1
RG_NAME=$2

if [ -z "$WEBAPP_NAME" ] || [ -z "$RG_NAME" ]; then
    echo "Usage: $0 <webapp-name> <resource-group-name>"
    exit 1
fi

echo "üîÑ SLOT SWAP - Bytter staging til production"
echo "==========================================="

# Pre-swap verification
echo "‚Üí Pre-swap: Tester staging slot..."
STAGING_URL="https://${WEBAPP_NAME}-staging.azurewebsites.net"
bash scripts/test-health.sh "$STAGING_URL" "staging"

# Utf√∏r swap
echo "‚Üí Utf√∏rer slot swap..."
az webapp deployment slot swap \
    --name "$WEBAPP_NAME" \
    --resource-group "$RG_NAME" \
    --slot staging \
    --target-slot production

echo "‚Üí Venter p√• at swap fullf√∏res..."
sleep 10

# Post-swap verification
echo "‚Üí Post-swap: Tester production slot..."
PROD_URL="https://${WEBAPP_NAME}.azurewebsites.net"
bash scripts/test-health.sh "$PROD_URL" "production"

echo "‚úÖ Slot swap fullf√∏rt og verifisert!"
EOF

# Gj√∏r scripts kj√∏rbare
chmod +x scripts/*.sh

# ============================================================================
# CI/CD WORKFLOWS
# ============================================================================

echo -e "${GREEN}‚öôÔ∏è  Genererer GitHub Actions workflows...${NC}"

cat > .github/workflows/pr-validation.yml << 'EOF'
name: PR Validation (Ephemeral)

on:
  pull_request:
    branches: [main]

env:
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

jobs:
  offline-tests:
    name: üîç Offline Testing
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
      
      - name: Run Offline Tests
        run: bash scripts/test-offline.sh

  policy-tests:
    name: üîê Policy & Compliance
    runs-on: ubuntu-latest
    needs: offline-tests
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
      
      - name: Terraform Init
        run: |
          cd terraform
          terraform init
      
      - name: Run Policy Tests
        run: bash scripts/test-policy.sh

  preview-deploy:
    name: üöÄ Preview Deploy (Ephemeral)
    runs-on: ubuntu-latest
    needs: [offline-tests, policy-tests]
    environment:
      name: pr-preview
    steps:
      - uses: actions/checkout@v4
      
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
      
      - name: Deploy Preview Environment
        run: |
          cd terraform
          terraform init
          terraform apply -auto-approve \
            -var="prefix=pr-${{ github.event.pull_request.number }}" \
            -var="resource_group_name=rg-webapp-pr-${{ github.event.pull_request.number }}"
      
      - name: Get Outputs
        id: tf-outputs
        run: |
          cd terraform
          echo "webapp_name=$(terraform output -raw webapp_name)" >> $GITHUB_OUTPUT
          echo "webapp_url=$(terraform output -raw webapp_url)" >> $GITHUB_OUTPUT
      
      - name: Verification Tests
        run: |
          bash scripts/test-verify.sh \
            ${{ steps.tf-outputs.outputs.webapp_name }} \
            rg-webapp-pr-${{ github.event.pull_request.number }}
      
      - name: Deploy Application
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ steps.tf-outputs.outputs.webapp_name }}
          package: ./app
      
      - name: Health Check
        run: |
          bash scripts/test-health.sh ${{ steps.tf-outputs.outputs.webapp_url }}
      
      - name: Cleanup (on failure)
        if: failure()
        run: |
          cd terraform
          terraform destroy -auto-approve \
            -var="prefix=pr-${{ github.event.pull_request.number }}" \
            -var="resource_group_name=rg-webapp-pr-${{ github.event.pull_request.number }}"

  cleanup-preview:
    name: üßπ Cleanup Preview
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true
    steps:
      - uses: actions/checkout@v4
      
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
      
      - name: Destroy Preview Environment
        run: |
          cd terraform
          terraform init
          terraform destroy -auto-approve \
            -var="prefix=pr-${{ github.event.pull_request.number }}" \
            -var="resource_group_name=rg-webapp-pr-${{ github.event.pull_request.number }}"
EOF

cat > .github/workflows/main-deploy.yml << 'EOF'
name: Main Deploy (Persistent)

on:
  push:
    branches: [main]
  schedule:
    - cron: '0 2 * * 1'  # Ukentlig rebuild (mandag 02:00)
  workflow_dispatch:  # Manuell trigger

env:
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

jobs:
  test-and-build:
    name: üß™ Test & Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Offline Tests
        run: bash scripts/test-offline.sh
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
      
      - name: Policy Tests
        run: |
          cd terraform
          terraform init
          cd ..
          bash scripts/test-policy.sh

  deploy-infrastructure:
    name: üèóÔ∏è  Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: test-and-build
    environment: production
    outputs:
      webapp_name: ${{ steps.tf-outputs.outputs.webapp_name }}
      resource_group: ${{ steps.tf-outputs.outputs.resource_group }}
      staging_url: ${{ steps.tf-outputs.outputs.staging_url }}
      prod_url: ${{ steps.tf-outputs.outputs.prod_url }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
      
      - name: Terraform Apply
        run: |
          cd terraform
          terraform init
          terraform apply -auto-approve
      
      - name: Get Outputs
        id: tf-outputs
        run: |
          cd terraform
          echo "webapp_name=$(terraform output -raw webapp_name)" >> $GITHUB_OUTPUT
          echo "resource_group=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
          echo "staging_url=$(terraform output -raw staging_url)" >> $GITHUB_OUTPUT
          echo "prod_url=$(terraform output -raw webapp_url)" >> $GITHUB_OUTPUT
      
      - name: Verify Infrastructure
        run: |
          bash scripts/test-verify.sh \
            ${{ steps.tf-outputs.outputs.webapp_name }} \
            ${{ steps.tf-outputs.outputs.resource_group }}

  deploy-to-staging:
    name: üöÄ Deploy to Staging
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    steps:
      - uses: actions/checkout@v4
      
      - name: Deploy to Staging Slot
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ needs.deploy-infrastructure.outputs.webapp_name }}
          slot-name: staging
          package: ./app
      
      - name: Staging Health Check
        run: |
          bash scripts/test-health.sh \
            ${{ needs.deploy-infrastructure.outputs.staging_url }} \
            staging

  swap-to-production:
    name: ‚ôªÔ∏è  Swap to Production
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-to-staging]
    environment: production-swap
    steps:
      - uses: actions/checkout@v4
      
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Slot Swap
        run: |
          bash scripts/swap-slots.sh \
            ${{ needs.deploy-infrastructure.outputs.webapp_name }} \
            ${{ needs.deploy-infrastructure.outputs.resource_group }}
      
      - name: Production Health Check
        run: |
          bash scripts/test-health.sh \
            ${{ needs.deploy-infrastructure.outputs.prod_url }} \
            production
EOF

# ============================================================================
# DOKUMENTASJON
# ============================================================================

echo -e "${GREEN}üìö Genererer dokumentasjon...${NC}"

cat > README.md << 'EOF'
# üöÄ Azure Web App Deployment Slots Lab

Praktisk √∏velse i moderne deployment-m√∏nstre med Azure App Service slots, Infrastructure as Code, og CI/CD.

## üìã L√¶ringsm√•l

Etter gjennomf√∏rt lab skal studentene kunne:
- ‚úÖ Sette opp Web App med staging/production slots ved hjelp av Terraform
- ‚úÖ Implementere sikker slot swap-strategi (blue-green deployment)
- ‚úÖ Bruke feature toggles for gradvis utrulling
- ‚úÖ Implementere multi-layer testing (offline ‚Üí policy ‚Üí verification ‚Üí outcomes)
- ‚úÖ Forst√• forskjellen mellom ephemeral (PR) og persistent (main) milj√∏er
- ‚úÖ Orkestere test-pipeline i CI/CD

## üèóÔ∏è Arkitektur

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Azure App Service Plan (Linux)      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ     Web App                       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇProduction‚îÇ ‚Üê‚îÄ‚îÄ‚Üí ‚îÇ  Staging   ‚îÇ ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  Slot    ‚îÇ SWAP ‚îÇ   Slot     ‚îÇ ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                                   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  Feature Toggle: OFF   Toggle: ON‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üö¶ Test-niv√•er

### 1. **Offline Testing** (scripts/test-offline.sh)
- Syntaks-validering (Terraform, Python)
- Linting
- Sikkerhetssjekk (hardkodede secrets)
- ‚úÖ **N√•r**: Ved hver kodeendring, lokalt og i CI

### 2. **Connected Static Analysis** (scripts/test-policy.sh)
- Policy compliance (p√•krevde tags)
- HTTPS-only enforcement
- FTP deaktivering
- TLS minimum version
- ‚úÖ **N√•r**: I PR-validering, f√∏r deployment

### 3. **Online Verification** (scripts/test-verify.sh)
- Sjekk at ressurser eksisterer
- Verifiser konfigurasjon
- Sammenlign slots
- ‚úÖ **N√•r**: Etter infrastructure deployment

### 4. **Online Outcomes** (scripts/test-health.sh)
- Health checks (HTTP 200)
- Feature toggle testing
- Response validation
- ‚úÖ **N√•r**: F√∏r og etter slot swap

## üéØ Oppgaver

### Del 1: Lokal Utvikling
1. **Setup milj√∏**
   ```bash
   # Installer dependencies
   pip install -r app/requirements.txt
   
   # Kj√∏r appen lokalt
   cd app
   export ENVIRONMENT=local
   export FEATURE_TOGGLE_X=true
   python app.py
   ```

2. **Test lokalt**
   ```bash
   curl http://localhost:8000/
   curl http://localhost:8000/health
   curl http://localhost:8000/feature-x
   ```

### Del 2: Infrastructure Deployment
1. **Login til Azure**
   ```bash
   az login
   ```

2. **Deploy med Terraform**
   ```bash
   cd terraform
   terraform init
   terraform plan
   terraform apply
   ```

3. **Verifiser deployment**
   ```bash
   cd ..
   WEBAPP_NAME=$(cd terraform && terraform output -raw webapp_name)
   RG_NAME=$(cd terraform && terraform output -raw resource_group_name)
   
   bash scripts/test-verify.sh $WEBAPP_NAME $RG_NAME
   ```

### Del 3: Application Deployment
1. **Deploy til staging**
   ```bash
   az webapp deployment source config-zip \
     --resource-group $RG_NAME \
     --name $WEBAPP_NAME \
     --slot staging \
     --src app.zip  # (create zip first: cd app && zip -r ../app.zip .)
   ```

2. **Test staging**
   ```bash
   STAGING_URL="https://${WEBAPP_NAME}-staging.azurewebsites.net"
   bash scripts/test-health.sh $STAGING_URL staging
   ```

### Del 4: Slot Swap
1. **Utf√∏r swap**
   ```bash
   bash scripts/swap-slots.sh $WEBAPP_NAME $RG_NAME
   ```

2. **Verifiser production**
   ```bash
   PROD_URL="https://${WEBAPP_NAME}.azurewebsites.net"
   bash scripts/test-health.sh $PROD_URL production
   ```

### Del 5: CI/CD Pipeline
1. **Sett opp GitHub repository**
   ```bash
   git init
   git add .
   git commit -m "Initial lab setup"
   git remote add origin <your-repo-url>
   git push -u origin main
   ```

2. **Konfigurer GitHub Secrets**
   - `AZURE_CREDENTIALS`: Service Principal JSON
   - `AZURE_CLIENT_ID`
   - `AZURE_CLIENT_SECRET`
   - `AZURE_SUBSCRIPTION_ID`
   - `AZURE_TENANT_ID`

3. **Test PR workflow**
   ```bash
   git checkout -b feature/test-change
   # Gj√∏r en endring i app/app.py
   git commit -am "Test change"
   git push origin feature/test-change
   # Opprett PR i GitHub
   ```

## üéì Diskusjonspunkter

1. **Blue-Green vs Canary Deployment**
   - Hva er forskjellen?
   - N√•r bruker man hvilken strategi?

2. **Feature Toggles**
   - Fordeler og ulemper?
   - Hvordan unng√• "technical debt"?

3. **Ephemeral Environments**
   - Hvorfor er PR-baserte milj√∏er nyttige?
   - Kostnad vs nytte?

4. **Test Pyramid**
   - Hvorfor flere offline tester enn online?
   - Balanse mellom hastighet og grundighet?

## üßπ Cleanup

```bash
cd terraform
terraform destroy
```

## üìö Ressurser

- [Azure App Service Documentation](https://learn.microsoft.com/en-us/azure/app-service/)
- [Deployment Slots Best Practices](https://learn.microsoft.com/en-us/azure/app-service/deploy-best-practices)
- [Terraform Azure Provider](https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs)

## ‚ùì Troubleshooting

**Problem**: Slot swap feiler
- ‚úÖ Sjekk at begge slots er healthy
- ‚úÖ Verifiser at app settings er korrekt konfigurert

**Problem**: Health check timeout
- ‚úÖ √òk timeout i test-health.sh
- ‚úÖ Sjekk app logs: `az webapp log tail`

**Problem**: Terraform state conflicts
- ‚úÖ Bruk remote backend (Azure Storage)
- ‚úÖ Eller bruk unik prefix per student

---

**üéâ Lykke til med labben!**
EOF

cat > docs/LAB-GUIDE.md << 'EOF'
# üìñ Detaljert Lab-guide

## Scenario

Du er DevOps-ingeni√∏r i et team som utvikler en web-applikasjon. Teamet √∏nsker √•:
1. Redusere risiko ved deployments
2. Teste nye features i produksjonslignende milj√∏
3. Kunne rulle tilbake raskt ved problemer
4. Automatisere testing og deployment

## Gjennomf√∏ring (4 timer)

### Time 1: Grunnleggende Forst√•else (60 min)

#### 1.1 Introduksjon til Deployment Slots (20 min)
- Hva er deployment slots?
- Blue-green deployment forklart
- Slot swap vs rolling deployment

**Praktisk demo**: Kj√∏r lokal app med ulike environment variabler

```bash
# Terminal 1: Production mode
export ENVIRONMENT=production FEATURE_TOGGLE_X=false
python app/app.py

# Terminal 2: Test forskjellen
curl http://localhost:8000/feature-x
```

#### 1.2 Infrastructure as Code (20 min)
- Terraform basics
- Azure provider konfigurasjon
- Resource dependencies

**Oppgave**: Analyser `terraform/main.tf`
- Identifiser alle ressurser
- Finn sikkerhetskonfigurasjoner (https_only, tls_version, ftp)
- Diskuter: Hvorfor er tags viktige?

#### 1.3 Test Strategi (20 min)
- Test pyramid
- Shift-left testing
- Cost of bugs

**Diskusjon**:
- Hva er kostnaden ved en bug i production vs staging vs development?
- Hvordan balanserer vi test-dekningsgrad mot utviklingshastighet?

### Time 2: Hands-on Infrastructure (60 min)

#### 2.1 Deploy Infrastructure (30 min)

```bash
# Login
az login

# Sett subscription (om n√∏dvendig)
az account set --subscription "Your Subscription"

# Deploy
cd terraform
terraform init
terraform plan  # Les outputen n√∏ye!
terraform apply

# Noter ned outputs
terraform output
```

**Oppgaver**:
1. √Öpne Azure Portal og verifiser at ressursene er opprettet
2. Sjekk tags p√• ressursene
3. Naviger til Web App ‚Üí Configuration ‚Üí Deployment slots

#### 2.2 Kj√∏r Offline og Policy Tests (15 min)

```bash
# Offline
bash scripts/test-offline.sh

# Policy
bash scripts/test-policy.sh
```

**Refleksjon**:
- Hvilke feil ville disse testene fanget opp?
- N√•r i utviklingsprosessen kj√∏res de?

#### 2.3 Kj√∏r Verification Tests (15 min)

```bash
WEBAPP_NAME=$(cd terraform && terraform output -raw webapp_name)
RG_NAME=$(cd terraform && terraform output -raw resource_group_name)

bash scripts/test-verify.sh $WEBAPP_NAME $RG_NAME
```

**Analyse**:
- Sjekk scriptet: Hva verifiseres?
- Hvordan ville du utvidet testene?

### Time 3: Application Deployment (60 min)

#### 3.1 Manuell Deploy til Staging (30 min)

```bash
# Pakk applikasjonen
cd app
zip -r ../app.zip . -x "*.pyc" -x "__pycache__/*"
cd ..

# Deploy til staging slot
az webapp deployment source config-zip \
  --resource-group $RG_NAME \
  --name $WEBAPP_NAME \
  --slot staging \
  --src app.zip

# Vent p√• at deployment fullf√∏res
sleep 30
```

**Test staging**:
```bash
STAGING_URL="https://${WEBAPP_NAME}-staging.azurewebsites.net"

# Health check
bash scripts/test-health.sh $STAGING_URL staging

# Manuell testing
curl $STAGING_URL
curl $STAGING_URL/feature-x
curl $STAGING_URL/health
```

#### 3.2 Sammenlign Staging og Production (15 min)

```bash
PROD_URL="https://${WEBAPP_NAME}.azurewebsites.net"

# Production (skal v√¶re tom/default n√•)
curl $PROD_URL

# Staging (skal ha din app)
curl $STAGING_URL
```

**Diskuter**:
- Hva ser du av forskjeller?
- Hvordan kan du teste at feature toggle fungerer?

#### 3.3 Slot Swap (15 min)

```bash
# Kj√∏r swap-script (inkluderer pre/post checks)
bash scripts/swap-slots.sh $WEBAPP_NAME $RG_NAME

# Verifiser
curl $PROD_URL
curl $PROD_URL/feature-x
```

**Eksperiment**:
1. Gj√∏r en endring i app.py (f.eks. endre welcome message)
2. Deploy til staging
3. Test staging
4. Swap til production
5. Verifiser endringen i production

### Time 4: CI/CD Automation (60 min)

#### 4.1 GitHub Actions Setup (20 min)

```bash
# Init git repo
git init
git add .
git commit -m "Initial lab setup"

# Opprett GitHub repo og push
git remote add origin <your-repo-url>
git push -u origin main
```

**Konfigurer Secrets** (i GitHub Settings ‚Üí Secrets):

Opprett Service Principal:
```bash
az ad sp create-for-rbac --name "github-webapp-lab" \
  --role contributor \
  --scopes /subscriptions/<subscription-id> \
  --sdk-auth
```

Legg til secrets:
- `AZURE_CREDENTIALS`: Hele JSON outputen fra kommandoen over
- `AZURE_CLIENT_ID`: `clientId` fra JSON
- `AZURE_CLIENT_SECRET`: `clientSecret` fra JSON
- `AZURE_SUBSCRIPTION_ID`: `subscriptionId` fra JSON
- `AZURE_TENANT_ID`: `tenantId` fra JSON

#### 4.2 Test PR Workflow (20 min)

```bash
# Opprett feature branch
git checkout -b feature/new-endpoint

# Legg til ny endpoint i app.py
cat >> app/app.py << 'ENDPOINT'

@app.route('/api/students')
def students():
    return jsonify({
        'students': ['Alice', 'Bob', 'Charlie'],
        'environment': ENVIRONMENT
    })
ENDPOINT

# Commit og push
git add app/app.py
git commit -m "Add students endpoint"
git push origin feature/new-endpoint
```

**I GitHub**:
1. Opprett Pull Request
2. Observer workflow kj√∏ring
3. Sjekk at alle tests passerer
4. Noter preview URL (i logs)
5. Test preview milj√∏et

#### 4.3 Merge og Production Deploy (20 min)

```bash
# Merge PR i GitHub UI

# Observ√©r main workflow
# - Kj√∏rer alle tests
# - Deployer til staging
# - Swapper til production
```

**Verifiser**:
1. Sjekk at production URL har den nye endpointen
2. Test: `curl $PROD_URL/api/students`
3. Sjekk at preview milj√∏et ble ryddet opp

## üéØ Ekstra Utfordringer

### Utfordring 1: Custom Health Checks
Utvid `/health` endpoint til √• sjekke:
- Database tilkobling (mock)
- External API (mock)
- Disk space

### Utfordring 2: Gradual Rollout
Modifiser swap-script til √•:
1. Route 10% trafikk til ny versjon
2. Vent 5 min
3. Sjekk error rate
4. Full swap eller rollback

### Utfordring 3: Monitoring
Legg til Application Insights:
- Custom metrics
- Exception tracking
- Performance monitoring

### Utfordring 4: Multi-stage Pipeline
Utvid workflow med:
- Dev environment (automatisk deploy)
- Test environment (deploy etter godkjenning)
- Prod environment (deploy etter godkjenning + smoke tests)

## üìä Evalueringskriterier

### Grunnleggende (best√•tt)
- ‚úÖ Infrastruktur deployet korrekt
- ‚úÖ Applikasjon kj√∏rer i begge slots
- ‚úÖ Slot swap utf√∏rt vellykket
- ‚úÖ Alle test-scripts kj√∏rer uten feil

### Avansert (h√∏y karakter)
- ‚úÖ CI/CD pipeline fullt fungerende
- ‚úÖ Forst√•r trade-offs i deployment-strategier
- ‚úÖ Implementert ekstra utfordringer
- ‚úÖ God dokumentasjon av endringer

## ü§î Refleksjonssp√∏rsm√•l

1. **Sikkerhet**
   - Hvilke sikkerhetstiltak er implementert?
   - Hva mangler? (Secrets management, network isolation, etc.)

2. **Skalerbarhet**
   - Hvordan ville du h√•ndtert 100x mer trafikk?
   - Database i samme setup?

3. **Kostnader**
   - Hva koster dette setuppet per m√•ned?
   - Hvordan optimalisere?

4. **Feilh√•ndtering**
   - Hva skjer hvis swap feiler?
   - Hvordan rulle tilbake?

5. **Team Workflow**
   - Hvordan ville flere utviklere jobbe sammen?
   - Branch strategi?

---

**Lykke til! üöÄ**
EOF

# ============================================================================
# TESTING UTILITIES
# ============================================================================

cat > tests/test-local-app.sh << 'EOF'
#!/bin/bash
# Test Flask app lokalt f√∏r deployment

set -e

echo "üß™ Testing Flask app locally..."

# Start appen i bakgrunnen
cd app
export ENVIRONMENT=test
export FEATURE_TOGGLE_X=true
python app.py &
APP_PID=$!
cd ..

# Vent p√• at appen starter
sleep 3

# Test endpoints
echo "‚Üí Testing / endpoint..."
curl -s http://localhost:8000/ | jq .

echo "‚Üí Testing /health endpoint..."
curl -s http://localhost:8000/health | jq .

echo "‚Üí Testing /feature-x endpoint..."
curl -s http://localhost:8000/feature-x | jq .

# Stopp appen
kill $APP_PID

echo "‚úÖ Local tests passed!"
EOF

chmod +x tests/test-local-app.sh

# ============================================================================
# GITIGNORE
# ============================================================================

cat > .gitignore << 'EOF'
# Terraform
terraform/.terraform/
terraform/.terraform.lock.hcl
terraform/terraform.tfstate
terraform/terraform.tfstate.backup
terraform/*.tfplan
terraform/*.json

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
venv/
ENV/
*.egg-info/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Secrets
*.pem
*.key
secrets.txt

# Build artifacts
*.zip
dist/
build/
EOF

# ============================================================================
# SCRIPTS FOR STUDENTS
# ============================================================================

cat > quick-start.sh << 'EOF'
#!/bin/bash

echo "üöÄ Azure Web App Slots Lab - Quick Start"
echo "========================================"
echo ""
echo "Dette scriptet guider deg gjennom setup."
echo ""

read -p "Har du Azure CLI installert? (y/n): " has_az
if [ "$has_az" != "y" ]; then
    echo "‚ùå Installer Azure CLI f√∏rst: https://docs.microsoft.com/en-us/cli/azure/install-azure-cli"
    exit 1
fi

read -p "Har du Terraform installert? (y/n): " has_tf
if [ "$has_tf" != "y" ]; then
    echo "‚ùå Installer Terraform f√∏rst: https://www.terraform.io/downloads"
    exit 1
fi

read -p "Er du logget inn i Azure? (y/n): " is_logged
if [ "$is_logged" != "y" ]; then
    echo "‚Üí Logger inn i Azure..."
    az login
fi

echo ""
echo "‚úÖ Prerequisites OK!"
echo ""
echo "üìö Neste steg:"
echo "1. Les README.md for oversikt"
echo "2. Les docs/LAB-GUIDE.md for detaljert guide"
echo "3. Start med 'cd terraform && terraform init'"
echo ""
echo "Lykke til! üéâ"
EOF

chmod +x quick-start.sh

# ============================================================================
# FERDIG!
# ============================================================================

echo ""
echo -e "${GREEN}‚úÖ Lab-oppsett fullf√∏rt!${NC}"
echo ""
echo -e "${BLUE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
echo -e "${BLUE}‚ïë                     üéâ FERDIG! üéâ                          ‚ïë${NC}"
echo -e "${BLUE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
echo ""
echo -e "${YELLOW}üìÅ Struktur opprettet:${NC}"
echo "   lab-webapp-slots/"
echo "   ‚îú‚îÄ‚îÄ terraform/          (Infrastructure as Code)"
echo "   ‚îú‚îÄ‚îÄ app/                (Flask web app)"
echo "   ‚îú‚îÄ‚îÄ scripts/            (Test og deploy scripts)"
echo "   ‚îú‚îÄ‚îÄ .github/workflows/  (CI/CD pipelines)"
echo "   ‚îú‚îÄ‚îÄ docs/               (Detaljert guide)"
echo "   ‚îî‚îÄ‚îÄ tests/              (Lokale tester)"
echo ""
echo -e "${YELLOW}üìñ Neste steg:${NC}"
echo "   cd lab-webapp-slots"
echo "   ./quick-start.sh"
echo "   cat README.md"
echo ""
echo -e "${GREEN}Lykke til med labben! üöÄ${NC}"
